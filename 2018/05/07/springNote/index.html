<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>spring知识点 | laofuzi123</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#框架学习  框架使用  框架结构+组件编写和配置规则+业务逻辑  了解框架部分原理   #Spring框架 ##Spring框架结构 ##Spring环境的搭建  导入开发包 导入配置文件applicationContext.xml  ##Spring IOC环境搭建  导入IOC开发包 导入applicationContext.xml  ##使用Spring IOC功能 IOC:控制反转，由容">
<meta property="og:type" content="article">
<meta property="og:title" content="spring知识点">
<meta property="og:url" content="http://yoursite.com/2018/05/07/springNote/index.html">
<meta property="og:site_name" content="laofuzi123">
<meta property="og:description" content="#框架学习  框架使用  框架结构+组件编写和配置规则+业务逻辑  了解框架部分原理   #Spring框架 ##Spring框架结构 ##Spring环境的搭建  导入开发包 导入配置文件applicationContext.xml  ##Spring IOC环境搭建  导入IOC开发包 导入applicationContext.xml  ##使用Spring IOC功能 IOC:控制反转，由容">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i.imgur.com/fGNVKYJ.png">
<meta property="og:image" content="http://i.imgur.com/fmWcigd.png">
<meta property="og:image" content="https://i.imgur.com/jnRjMlT.png">
<meta property="og:image" content="http://yoursite.com/2018/05/07/springNote/jdbctemplate.png">
<meta property="og:image" content="http://i.imgur.com/LH740ZS.png">
<meta property="og:image" content="http://i.imgur.com/UbOqzRW.png">
<meta property="og:image" content="http://i.imgur.com/nPnbLRp.png">
<meta property="og:image" content="http://i.imgur.com/ufmHxeL.png">
<meta property="og:image" content="http://i.imgur.com/NzMQ5Dp.png">
<meta property="og:image" content="http://i.imgur.com/MJPEp2s.png">
<meta property="og:image" content="http://i.imgur.com/FyurJRM.png">
<meta property="og:image" content="http://i.imgur.com/46PjnQw.png">
<meta property="og:image" content="http://i.imgur.com/7GeInQL.png">
<meta property="og:image" content="http://i.imgur.com/BbGXxae.png">
<meta property="og:image" content="http://i.imgur.com/7h7blhS.png">
<meta property="og:image" content="http://i.imgur.com/yGeAVGS.png">
<meta property="og:image" content="http://i.imgur.com/sTe59xo.png">
<meta property="og:image" content="http://i.imgur.com/wTSzNUL.png">
<meta property="og:image" content="http://i.imgur.com/kFLaFEX.png">
<meta property="og:image" content="http://i.imgur.com/0R8461t.png">
<meta property="og:image" content="http://i.imgur.com/t61tfoZ.png">
<meta property="og:image" content="https://i.imgur.com/jUWuwwq.png">
<meta property="og:image" content="https://i.imgur.com/huUt1Po.png">
<meta property="og:image" content="https://i.imgur.com/fUCrT83.png">
<meta property="og:image" content="https://i.imgur.com/DBqRqcN.png">
<meta property="og:image" content="https://i.imgur.com/FGzECIe.png">
<meta property="og:updated_time" content="2018-05-07T14:20:26.663Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring知识点">
<meta name="twitter:description" content="#框架学习  框架使用  框架结构+组件编写和配置规则+业务逻辑  了解框架部分原理   #Spring框架 ##Spring框架结构 ##Spring环境的搭建  导入开发包 导入配置文件applicationContext.xml  ##Spring IOC环境搭建  导入IOC开发包 导入applicationContext.xml  ##使用Spring IOC功能 IOC:控制反转，由容">
<meta name="twitter:image" content="http://i.imgur.com/fGNVKYJ.png">
  
    <link rel="alternate" href="/atom.xml" title="laofuzi123" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">laofuzi123</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-springNote" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/07/springNote/" class="article-date">
  <time datetime="2018-05-07T14:20:54.749Z" itemprop="datePublished">2018-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      spring知识点
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#框架学习</p>
<ol>
<li><p>框架使用</p>
<p> 框架结构+组件编写和配置规则+业务逻辑</p>
</li>
<li><p>了解框架部分原理</p>
</li>
</ol>
<p>#Spring框架</p>
<p>##Spring框架结构<br><img src="http://i.imgur.com/fGNVKYJ.png" alt=""></p>
<p>##Spring环境的搭建</p>
<ol>
<li>导入开发包</li>
<li>导入配置文件applicationContext.xml</li>
</ol>
<p>##Spring IOC环境搭建</p>
<ol>
<li>导入IOC开发包</li>
<li>导入applicationContext.xml</li>
</ol>
<p>##使用Spring IOC功能</p>
<p>IOC:控制反转，由容器创建组件对象，然后注入参数建立应用关系（set、构造器）。</p>
<p>  EmpDAO–&gt;BasicDataSource</p>
<p>  编写规则：接收注入一方，需要定义set方法或带参数构造器  </p>
<pre><code>//原理，利用反射创建对象(无参构造器)，然后利用反射注入参数
&lt;bean id=&quot;&quot; class=&quot;xxxx&quot;&gt;
   &lt;property name=&quot;&quot; value|ref=&quot;xx&quot;&gt;
&lt;/bean&gt;
//原理，利用反射直接调用带参数构造器创建对象
 &lt;bean id=&quot;&quot; class=&quot;xxxx&quot;&gt;
   &lt;contructor-arg index=&quot;&quot; value|ref=&quot;xx&quot;&gt;
&lt;/bean&gt;
</code></pre><p><img src="http://i.imgur.com/fmWcigd.png" alt=""></p>
<p>##Spring DAO环境搭建</p>
<ol>
<li>导入IOC、AOP、DAO框架、ojdbc数据库驱动包、dbcp</li>
<li>导入applicationContext.xml</li>
</ol>
<p>##Spring DAO应用</p>
<h2 id="案例1：-利用JdbcTemplate访问咨询信息表"><a href="#案例1：-利用JdbcTemplate访问咨询信息表" class="headerlink" title="案例1： 利用JdbcTemplate访问咨询信息表"></a>案例1： 利用JdbcTemplate访问咨询信息表</h2><ol>
<li><p>追加开发环境jar包</p>
<ul>
<li>spring ioc、aop、dao模块开发包</li>
<li>ojdbc.jar、dbcp连接池包</li>
</ul>
</li>
<li><p>追加src下的applicationContext.xml配置文件</p>
</li>
<li><p>功能设计</p>
<p> <img src="https://i.imgur.com/jnRjMlT.png" alt=""></p>
<p> <img src="jdbctemplate.png" alt=""></p>
</li>
<li><p>实现设计</p>
<ul>
<li><p>配置DataSource</p>
<pre><code>&lt;bean id=&quot;dbcp&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
    &lt;property name=&quot;username&quot; value=&quot;SCOTT&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;password&quot; value=&quot;TIGER&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@localhost:1521:XE&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>配置JdbcTemplate</p>
<pre><code>&lt;bean id=&quot;template&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; ref=&quot;dbcp&quot;&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>实例化Spring容器，获取template应用</p>
<pre><code>@Test
public void test1(){
    //实例化Spring容器对象，获取JdbcTemplate对象
    String conf = &quot;applicationContext.xml&quot;;
    ApplicationContext ac = new ClassPathXmlApplicationContext(conf);
    JdbcTemplate template = ac.getBean(&quot;template&quot;,JdbcTemplate.class);
    String sql = &quot;select * from XDL_NEWS&quot;;
    List&lt;News&gt; list = template.query(
        sql, new BeanPropertyRowMapper&lt;News&gt;(News.class));
    for(News news : list){
        System.out.println(news.getId()+&quot; &quot;+news.getTitle());
    }
}
</code></pre></li>
<li><p>RowMapper组件，可以自己编写，也可以使用框架提供的BeanPropertyRowMapper</p>
<ul>
<li><p>自定义RowMapper，需要实现RowMapper接口及方法</p>
<p>  当ResultSet查询结果字段名和实体类属性名不一致，需要采用此方法。</p>
</li>
<li><p>框架提供的BeanPropertyRowMapper</p>
<p>  可以将同名字段值取出，给同名属性赋值，自动完成记录的封装。同名可以采用此方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>编写NewsDao组件</p>
<pre><code>@Repository(&quot;newsDao&quot;)//指定id等于newsDao
public class JdbcNewsDao implements NewsDao{

    @Autowired
    private JdbcTemplate template;
    //注解方式注入,set方法可省略

    @Override
    public List&lt;News&gt; loadAll() {
        String sql = &quot;select * from XDL_NEWS&quot;;
        List&lt;News&gt; list = template.query(
            sql, new NewsMapper());
        return list;
    }
}
</code></pre><p> 开启组件扫描，将NewsDao扫描到Spring容器创建对象，并注入JdbcTemplate使用</p>
<pre><code>&lt;!-- 开启组件扫描,
@Controller、@Service、@Repository、@Component、
    @Resource、@Autowired --&gt;
&lt;context:component-scan base-package=&quot;cn.xdl.dao&quot;/&gt;
</code></pre></li>
</ol>
<p>测试</p>
<pre><code>@Test
public void test2(){
    //实例化Spring容器对象，获取JdbcTemplate对象
    String conf = &quot;config/applicationContext.xml&quot;;
    ApplicationContext ac = new ClassPathXmlApplicationContext(conf);
    NewsDao newDao = ac.getBean(&quot;newsDao&quot;,JdbcNewsDao.class);
    List&lt;News&gt; list = newDao.loadAll();
    for(News news : list){
        //    System.out.println(news.getId()+&quot; &quot;+news.getTitle());
        System.out.println(news);
    }
}
</code></pre><p>使用JdbcTemplate编写DAO</p>
<pre><code>- 编写Dept实体类（属性名和字段名保持一致）
- 定义DeptDao接口
- 根据DeptDao接口编写实现类（使用JdbcTemplate）
    - 将DeptDao实现类扫描到Spring容器
    - 将JdbcTemplate注入到DeptDao实现类中
    - 使用JdbcTemplate.update/query等方法操作sql
</code></pre><p>#事务管理</p>
<pre><code>Spring支持两种模式，编程模式和声明模式（配置）。

使用方法如下：
- 在Spring容器中定义一个DataSourceTransactionManager组件对象
- 开启事务注解标记@Transactional
- 在组件代码中(类前/方法前)追加@Transactional标记
</code></pre><p>#Spring Web MVC环境搭建</p>
<ul>
<li>导入webmvc、ioc开发包</li>
<li>导入applicationContext.xml配置文件</li>
</ul>
<p>#Spring Web MVC应用</p>
<p>##流程和结构</p>
<p>作用：可以构建一个MVC结构的web程序。</p>
<p><img src="http://i.imgur.com/LH740ZS.png" alt=""></p>
<p>##开发过程（hello入门示例）</p>
<ol>
<li><p>设计一个处理流程</p>
<p> /hello.do–&gt;DispatcherServlet(主)–&gt;HandlerMapping–&gt;HelloController–&gt;(M模型)–&gt;ViewResolver–&gt;/hello.jsp    </p>
</li>
</ol>
<p>###实现设计流程</p>
<ol>
<li><p>搭建Spring Web MVC开发环境</p>
<ul>
<li>创建项目工程project</li>
<li>导入需要相关的jar包(ioc、webmvc)</li>
<li>导入Spring配置文件spring-mvc.xml</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>编写流程中缺失的组件</p>
<ul>
<li><p>HelloController</p>
<p>实现Controller接口，然后在接口的handleRequest方法中处理请求，最终返回ModelAndView对象。</p>
<p>ModelAndView封装了模型数据和视图名。</p>
<p>  public class HelloController implements Controller{</p>
<pre><code>@Override//ModelAndView封装模型数据和视图名
public ModelAndView handleRequest(
    HttpServletRequest request, HttpServletResponse response) throws Exception {
    ModelAndView mav = new ModelAndView();
    mav.setViewName(&quot;hello&quot;);//设置视图名字，例如hello.jsp名为hello
    mav.getModel().put(&quot;msg&quot;, &quot;我是Spring Web MVC&quot;);//将消息传递到hello.jsp去
    return mav;
}
</code></pre><p>  }</p>
</li>
</ul>
</li>
</ol>
<pre><code>- Java编码
    - 编写一个hello.jsp

            &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
                pageEncoding=&quot;UTF-8&quot;%&gt;
            &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
            &lt;html&gt;
            &lt;head&gt;
            &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
            &lt;title&gt;hello&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;h1&gt;欢迎学习Spring Web MVC&lt;/h1&gt;
            &lt;/body&gt;
            &lt;/html&gt;        

    - 编写HelloController

            //实现Controller接口和方法
            public class HelloController implements Controller{

                public ModelAndView handleRequest(
                        HttpServletRequest request, HttpServletResponse response) throws Exception {
                    // TODO 调用Dao组件处理
                    ModelAndView av = new ModelAndView();//可以存储模型数据和视图名称
                    av.getModel().put(&quot;msg&quot;, &quot;Hello world&quot;);//等价于request.setAttribute(&quot;msg&quot;,&quot;xxx&quot;)
                    av.setViewName(&quot;hello&quot;);//视图名(hello.jsp视图名为hello)
                    return av;
                }

            }

- XML配置

    - 配置DispatcherServlet（web.xml）

             &lt;servlet&gt;
                  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
                  &lt;servlet-class&gt;
                  org.springframework.web.servlet.DispatcherServlet
                  &lt;/servlet-class&gt;
                  &lt;!-- 指定spring容器配置文件 --&gt;
                  &lt;init-param&gt;
                      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
                      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
                  &lt;/init-param&gt;
              &lt;/servlet&gt;

              &lt;servlet-mapping&gt;
                  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
                  &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
              &lt;/servlet-mapping&gt;

    - 配置HandlerMapping（spring配置）

            &lt;bean id=&quot;handlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
                &lt;property name=&quot;mappings&quot;&gt;
                    &lt;props&gt;
                        &lt;!-- key指定请求；value指定Controller对象的id名 --&gt;
                        &lt;prop key=&quot;/hello.do&quot;&gt;helloController&lt;/prop&gt;
                    &lt;/props&gt;
                &lt;/property&gt;
            &lt;/bean&gt;

    - 配置HelloController（spring配置）

            &lt;bean id=&quot;helloController&quot; class=&quot;cn.xdl.controller.HelloController&quot;&gt;
            &lt;/bean&gt;

    - 配置ViewResolver（spring配置）

            &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
                &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&gt;&lt;/property&gt;
                &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
            &lt;/bean&gt;
</code></pre><p>##案例3：列表显示</p>
<ol>
<li>设计流程</li>
</ol>
<p>/news.do–&gt;DispatcherServlet–&gt;HandlerMapping–&gt;NewsListController–&gt;ViewResolver–&gt;/news.jsp</p>
<ol start="2">
<li>编写缺失组件</li>
</ol>
<ul>
<li>编写NewsListController</li>
<li>编写new.jsp</li>
</ul>
<ol start="3">
<li><p>配置处理流程</p>
<ul>
<li>配置DispatcherServlet(不用做了，前面做了)</li>
<li>配置HandlerMapping(追加一个<prop>定义)</prop></li>
<li>配置NewsListController(追加定义)</li>
<li>配置ViewResolver(不用做了，前面做了)</li>
</ul>
</li>
</ol>
<p>#Spring MVC注解配置</p>
<p>##1）HandlerMapping改变</p>
<p>  XML配置采用的是SimpleUrlHandlerMapping，注解配置采用的是RequestMappingHandlerMapping组件。</p>
<ul>
<li><p>SimpleUrlHandlerMapping配置格式</p>
<pre><code>&lt;bean id=&quot;handlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
    &lt;props&gt;
    &lt;!-- key指定请求；value指定Controller对象的id名 --&gt;
    &lt;prop key=&quot;/hello.do&quot;&gt;helloController&lt;/prop&gt;
    &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>RequestMappingHandlerMapping配置格式</p>
<pre><code>&lt;bean id=&quot;handlerMapping&quot; class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;
&lt;/bean&gt;
</code></pre><p>  简化配置</p>
<pre><code>&lt;mvc:annotation-driven /&gt;
</code></pre><p>  需要在Controller组件方法前使用@RequestMapping(“/hello.do”)</p>
</li>
</ul>
<p>##2）Controller改变</p>
<p>  XML配置时，Controller要求必须实现Controller接口及约定的handleRequest方法。<br>  注解配置时，Controller可以不用实现Controller接口，处理方法可以灵活定义。一般采用下面格式</p>
<pre><code>@RequestMapping(&quot;/hello.do&quot;)
public ModelAndView xxx(){...}
public String xxx(Model model){...}

//request和response参数可以根据需要追加
</code></pre><p>##登录处理</p>
<ol>
<li>显示登录页面</li>
</ol>
<p>/tologin.do–&gt;DispatcherServlet–&gt;HandlerMapping–&gt;LoginController<br>–&gt;ViewResolver–&gt;/WEB-INF/login.jsp</p>
<ol start="2">
<li>登录按钮处理</li>
</ol>
<p>/login.do–&gt;DispatcherServlet–&gt;HandlerMapping–&gt;LoginController<br>–&gt;ViewResolver–&gt;成功/WEB-INF/hello.jsp;失败/WEB-INF/login.jsp</p>
<p>##部门添加</p>
<ol>
<li>显示添加页面</li>
</ol>
<p>/toadd.do–&gt;DispatcherServlet–&gt;HandlerMapping–&gt;DeptController–&gt;ViewResolver–&gt;/WEB-INF/add.jsp</p>
<ol start="2">
<li>添加部门按钮处理</li>
</ol>
<p>/add.do–&gt;DispatcherServlet–&gt;HandlerMapping–&gt;DeptContoller–&gt;viewResolver–&gt;列表页面</p>
<p>##Controller接收请求参数方法</p>
<ol>
<li><p>利用原有HttpServletRequest接收</p>
</li>
<li><p>利用Controller方法的参数接收</p>
<p> （参数名和请求参数key保持一致，不一致可以使用@RequestParam(“key”)注解标记）</p>
</li>
<li><p>利用Controller方法实体对象参数接收</p>
<p> （实体对象属性名与请求参数key保持一致）</p>
</li>
</ol>
<p>##Controller接收POST中文乱码解决方法</p>
<p>Spring提供了一个CharacterEncodingFilter组件，内置request.setCharacterEncoding(xxx)，只需要在web.xml配置下该Filter即可。</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
    org.springframework.web.filter.CharacterEncodingFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><p>##Controller向JSP传数据</p>
<ol>
<li>利用HttpServletRequest对象</li>
<li>利用ModelAndView对象做返回值</li>
<li><p>利用Model或ModelMap参数对象</p>
<p> public String xxx(Model model){</p>
<p> }</p>
</li>
<li><p>利用HttpSession对象</p>
<p> 通过以上方法都可以将Controller数据传递到JSP页面，然后在JSP页面采用EL表达式获取即可。</p>
</li>
</ol>
<p>##Controller实现请求转发和重定向</p>
<ul>
<li><p>Controller方法返回值为String</p>
<pre><code>可以采用&quot;redirect:url地址&quot;格式。

  @RequestMapping(&quot;/add.do&quot;)
  public String add(Dept dept){
      //调用DeptDao保存
      deptDao.save(dept);
      return &quot;redirect:list.do&quot;;//采用重定向方式发出一个list.do请求
  }
</code></pre></li>
<li><p>Controller方法返回值为ModelAndView</p>
<pre><code>@RequestMapping(&quot;/add.do&quot;)
public ModelAndView add(Dept dept){
    //调用DeptDao保存
    deptDao.save(dept);
    ModelAndView av = new ModelAndView();
    av.setView(new RedirectView(&quot;url地址&quot;));
    return av;
}
</code></pre></li>
</ul>
<p>##拦截器</p>
<p>  在SpringMVC提供一种拦截器组件，拦截器组件可以在原有MVC处理流程中插入额外代码逻辑，也可以打断流程处理。</p>
<p>  <img src="http://i.imgur.com/UbOqzRW.png" alt=""></p>
<ol>
<li><p>拦截器组件编写规则</p>
<p>   <strong>实现HandlerInterceptor接口，例如</strong></p>
<p> public class CheckLoginInterceptor implements HandlerInterceptor{</p>
<pre><code>public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)throws Exception {
    // TODO 处理逻辑3

}

public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)throws Exception {
    // TODO 处理逻辑2
}

//如果返回true表示继续调用Controller后续流程；
//如果返回false表示终止后续流程的执行
public boolean preHandle(
    HttpServletRequest request, 
    HttpServletResponse response, 
    Object arg2) throws Exception {
    //TODO 处理逻辑1
}
</code></pre><p> }</p>
</li>
</ol>
<ol start="2">
<li><p>拦截器组件配置规则</p>
<pre><code>&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!-- 要拦截的请求 --&gt;
        &lt;mvc:mapping path=&quot;/*&quot;/&gt;
        &lt;!-- 要排除不进行拦截的请求 --&gt;
        &lt;mvc:exclude-mapping path=&quot;/tologin.do&quot;/&gt;
        &lt;mvc:exclude-mapping path=&quot;/login.do&quot;/&gt;
        &lt;!-- 指定拦截器组件 --&gt;
        &lt;bean class=&quot;cn.xdl.interceptor.CheckLoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre></li>
</ol>
<p>#异常处理 </p>
<p>请求–&gt;DispatcherServlet–&gt;HandlerMapping<br>–&gt;Controller–&gt;Service–&gt;Dao–&gt;(操作DB)<br>–&gt;ViewResolver–&gt;JSP视图</p>
<p>##原始异常处理模式</p>
<pre><code>@Controller
public class DeptController(){

    @RequestMapping(&quot;/add.do&quot;)
    public String add(){
        try{
            //调用Service+Dao添加处理
            return  &quot;redirect:list.do&quot;;
        }catch(Exception e){
            return &quot;error&quot;;//跳转到error.jsp
        }
    }        

    @RequestMapping(&quot;/delete.do&quot;)
    public String add(){
        try{
            //调用Service+Dao删除处理
            return  &quot;redirect:list.do&quot;;
        }catch(Exception e){
            return &quot;error&quot;;//跳转到error.jsp
        }
    }    


    @RequestMapping(&quot;/update.do&quot;)
    public String add(){
        try{
            //调用Service+Dao更新处理
            return  &quot;redirect:list.do&quot;;
        }catch(Exception e){
            return &quot;error&quot;;//跳转到error.jsp
        }
    }        

}
</code></pre><p>##SpringMVC异常处理</p>
<pre><code>@Controller
public class DeptController(){

    @RequestMapping(&quot;/add.do&quot;)
    public String add(){
        //调用Service+Dao添加处理
        rturn  &quot;redirect:list.do&quot;;
    }        

    @RequestMapping(&quot;/delete.do&quot;)
    public String add(){
        //调用Service+Dao删除处理
        return  &quot;redirect:list.do&quot;;
    }    


    @RequestMapping(&quot;/update.do&quot;)
    public String add(){
        //调用Service+Dao更新处理
        return  &quot;redirect:list.do&quot;;
    }        
}
</code></pre><p>###方法一</p>
<p>可以在Spring配置文件中定义SimpleMappingExceptionResolver</p>
<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
    &lt;property name=&quot;exceptionMappings&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;java.lang.Exception&quot;&gt;error&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>##文件上传</p>
<p>##Ajax</p>
<pre><code>Ajax页面局部刷新、异步处理。

XMLHttpRequest/$.ajax、$.get、$.post
</code></pre><ol>
<li><p>Ajax请求的处理过程</p>
<p> <img src="http://i.imgur.com/nPnbLRp.png" alt=""></p>
</li>
</ol>
<ol start="2">
<li><p>传统请求的处理过程</p>
<p> <img src="http://i.imgur.com/ufmHxeL.png" alt=""></p>
</li>
</ol>
<p>##SpringMVC+Ajax</p>
<pre><code>SpringMVC提供一个JSON响应，简单方便。
</code></pre><ol>
<li><p>SpringMVC传统请求的处理过程</p>
<p> <img src="http://i.imgur.com/NzMQ5Dp.png" alt=""></p>
</li>
<li><p>SpringMVCAjax请求的处理过程</p>
<p> <img src="http://i.imgur.com/MJPEp2s.png" alt=""></p>
</li>
<li><p>SpringMVC+Ajax案例</p>
<p> (Ajax)/view.do?id=xx–&gt;DispatcherServlet–&gt;HandlerMapping–&gt;DeptController–&gt;@ResponseBody–&gt;返回JSON结果（部门对象的json结果）</p>
<ul>
<li>为工程添加gson.jar开发包</li>
<li>编写Controller业务处理方法，将输出对象做返回值</li>
<li><p>在Controller业务方法前追加@ResponseBody标记</p>
<p>  比如想输出一个Dept对象信息,就return dept;</p>
<pre><code>@RequestMapping(&quot;/view1.do&quot;)
@ResponseBody//不再调用ViewResolver处理，
//而是找jackson或gson工具包将返回结果转成json字符串输出
public Dept load(int id){
    //根据id查询部门信息
    Dept dept = deptDao.findById(id);
    return dept;
}
</code></pre></li>
</ul>
</li>
</ol>
<p>#自定义一个MyBatis框架</p>
<p>1.实体类、2.SQL定义文件、3.主配置文件</p>
<p>1.XML解析、2.反射(动态创建对象、调用对象方法)、3.ResultSetMetaData、4.JDBC技术、5.设计模式</p>
<p>#Spring+MyBatis应用</p>
<p>关键点：如何将Mapper映射器对象放入Spring容器。</p>
<p>前提工作：引入一个mybatis-spring.jar整合包。</p>
<ul>
<li><p>SqlSessionFactoryBean<br>作用：用于创建SqlSessionFactory对象。封装了原有mybatis中的SqlSessionFactoryBuilder、SqlSessionFactory API</p>
</li>
<li><p>MapperFactoryBean（一次定义只能为一个Mapper生成）</p>
<p>作用：根据Mapper映射器接口创建对象，在Spring容器中创建。封装了原有mybatis中SqlSession的使用</p>
</li>
<li><p>MapperScannerConfigurer（一次定义只能为多个Mapper生成）</p>
<p>作用：可以根据指定包下的Mapper映射器接口，批量创建多个Mapper接口对象。</p>
</li>
<li><p>SqlSessionTemplate</p>
<p>作用：用于调用SqlSession执行增删改查SQL语句。</p>
</li>
</ul>
<p><img src="http://i.imgur.com/FyurJRM.png" alt=""></p>
<p>#方案1</p>
<p> 特点：使用MyBatis中的Mapper映射器做Dao操作。</p>
<p> 使用SqlSessionFactoryBean+MapperScannerConfigurer</p>
<p>#方案2</p>
<p> 特点：自定义Dao接口和实现类。</p>
<p> 使用SqlSessionFactoryBean+SqlSessionTemplate,自己编写Dao接口和实现类。</p>
<p>#事务控制</p>
<p> public  void  service1(){<br>    //逻辑处理1<br>    //逻辑处理2<br> }</p>
<p> public  void  service1(){<br>   try{<br>    //逻辑处理1<br>    //逻辑处理2<br>    //提交事务<br>   }catch(){<br>    //回滚事务<br>   }<br> }</p>
<p> @Transactional<br> public  void  service1(){<br>    //逻辑处理1<br>    //逻辑处理2<br> }</p>
<p>#分层处理</p>
<p>Controller–&gt;Service–&gt;Dao</p>
<p><img src="http://i.imgur.com/46PjnQw.png" alt=""></p>
<p>#Spring AOP</p>
<p>##概念</p>
<p>  AOP: Aspect Oriented Programming 面向方面/切面编程.<br>  重心：切面，分析寻找共通切面  </p>
<p>  OOP: Object Oriented Programming 面向对象编程<br>  OOAD:面向对象分析和设计（定义类及其内部属性和方法）<br>  重心：对象，分析设计类  </p>
<p>  AOP还是OOP编程，主要目的是将共通业务逻辑跟传统业务进行拆分，然后通过配置模式将两个业务组件结合。（将共通业务和传统业务解耦），例如事务逻辑、异常处理逻辑、性能监控。</p>
<p>  优点：在原有代码不修改情况下，追加新的功能逻辑。</p>
<p>  <img src="http://i.imgur.com/7GeInQL.png" alt=""></p>
<p>##应用</p>
<ol>
<li><p>方面/切面（Aspect，加什么功能？）</p>
<p> 在同一时刻、执行的共通的处理逻辑（时机+功能）。<br> 方面组件指的是封装了共通处理的组件。</p>
</li>
<li><p>切入点（Pointcut，给谁加？）</p>
<p> 指定切入的目标组件及方法。Spring提供了多种切入点表达式</p>
<ul>
<li><p>方法限定表达式    </p>
<blockquote>
<p>execution(修饰符? 返回类型 方法名(参数) throws异常?)</p>
</blockquote>
<pre><code>//匹配Spring容器中所有以save打头的方法
execution(* save*(..))
</code></pre><p>  //匹配AddressServiceImpl组件中所有方法<br>  execution(<em> cn.xdl.service.AddressServiceImpl.</em>(..))<br>  //匹配cn.xdl.service包下所有类所有方法<br>  execution(<em> cn.xdl.service.</em>.<em>(..))<br>  //匹配cn.xdl.service包和子包下所有类所有方法<br>  execution(</em> cn.xdl.service..<em>.</em>(..))</p>
</li>
<li><p>类型限定表达式</p>
<blockquote>
<p>within(包名.类型名)</p>
</blockquote>
<p>  //匹配AddressServiceImpl类所有方法<br>  within(cn.xdl.service.AddressServiceImpl)<br>  //匹配cn.xdl.service包下所有类所有方法<br>  within(cn.xdl.service.<em>)<br>  //匹配cn.xdl.service包和子包下所有类所有方法<br>  within(cn.xdl.service..</em>)</p>
</li>
</ul>
</li>
</ol>
<pre><code>- bean名称限定表达式

&gt; bean(Spring容器中对象的id名)

    //匹配id=addressService的对象所有方法
    bean(addressService)
    //匹配id名以Service结尾的对象所有方法
    bean(*Service)


可以使用&amp;&amp;、||、!符号将多个表达式连接使用。
</code></pre><ol start="3">
<li><p>通知（Advice，什么时机加？）</p>
<p> 指定追加切面组件功能的时机。例如在目标方法之前、之后等等。<br>Spring提供以下几种时机。<br> try{</p>
<pre><code>//使用环绕通知-前置逻辑&lt;aop:around&gt;
//使用前置通知--&lt;aop:before&gt;
//执行目标方法处理
//使用后置通知--&lt;aop:after-returning&gt;
//使用环绕通知-后置逻辑
</code></pre><p> }catch(){</p>
<pre><code>//使用异常通知--&lt;aop:after-throwing&gt;
</code></pre><p> }finally{</p>
<pre><code>//使用最终通知--&lt;aop:after&gt;
</code></pre><p> }</p>
</li>
</ol>
<p>##注解配置</p>
<ol>
<li><p>开启组件扫描，将方面组件扫描，追加@Component标记</p>
<pre><code>&lt;context:component-scan base-package=&quot;cn.xdl.jd.aop&quot;/&gt;
</code></pre></li>
</ol>
<ol start="2">
<li><p>开启AOP注解配置，追加@Aspect、@Before、@After等标记</p>
<pre><code>&lt;aop:aspectj-autoproxy /&gt;
</code></pre></li>
</ol>
<p>##AOP案例1</p>
<pre><code>需求：检测每个请求处理耗费时间。

- 切面组件

    计时，计算时间差额，在控制台打印。

- 切入点

    给所有Controller组件方法
    within(cn.xdl.jd.controller.*)

- 通知

    环绕通知
    &lt;aop:around&gt;--@Around
</code></pre><p>   前置和最终通知的方法定义规则：</p>
<pre><code>public void xxx(){...}
</code></pre><p>   <strong>环绕通知方法定义规则：</strong></p>
<pre><code>public Object xxx(ProceedingJoinPoint pjp) throws Throwable{...}
</code></pre><p>   <strong>异常通知方法定义规则：</strong></p>
<pre><code>public void xxx(Exception e){...}
</code></pre><p>   后置通知方法定义规则：</p>
<pre><code>public void xxx(Object retVal){...}
</code></pre><p>##AOP案例2</p>
<pre><code>需求：将请求处理中的异常信息记录到文件中。
</code></pre><ol>
<li><p>切面组件</p>
<p> 将异常信息写入文件，（文件位置、文件名）</p>
</li>
<li><p>切入点</p>
<p> 作用到所有Service组件上<br> within(cn.xdl.jd.service..*)</p>
</li>
<li><p>通知</p>
<p> 异常通知。<br> <a href="aop:after-throwing" target="_blank" rel="noopener">aop:after-throwing</a>----@AfterThrowing</p>
</li>
</ol>
<p>##AOP原理（了解）</p>
<p>  Spring采用了动态代理技术实现了AOP控制。</p>
<p>  动态代理技术：动态生成一个类（代理类）、动态编译创建对象（代理对象）。</p>
<p>  当Spring采用了AOP配置后，Spring容器返回的目标对象类型是利用动态代理技术生成的代理类对象，该对象方法将目标组件方法做了重写，内部调用原有目标组件功能+切面组件功能。</p>
<p><img src="http://i.imgur.com/BbGXxae.png" alt=""></p>
<p>  Spring代理技术有：Java JDK Proxy API和CGLIB工具。<br>  默认情况下，如果目标组件有接口，采用Proxy API；  </p>
<pre><code>public class $Proxy25 implements AddressService{
      public List&lt;Address&gt; loadUserAddress(int userId){
          //调用AddressServiceImpl对象loadUserAddress()处理
          //调用切面组件处理逻辑
      }
}
</code></pre><p>  如果目标组件没有接口，采用CGLIB工具。</p>
<pre><code>public class XxxxBySpringCGLIB$3323 extends  AddressServiceImpl{
    public List&lt;Address&gt; loadUserAddress(int userId){
         super.loadUserAddress(userId);
         //调用切面组件处理逻辑
    }
} 
</code></pre><p>  在XML配置中，可以追加属性，proxy-target-class强制采用CGLIB技术生成代理对象(更安全)。</p>
<p>  &lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;</p>
<p>#Mybatis框架</p>
<p><strong>(SSM:SpringMVC+Spring(IOC/AOP)+MyBatis)</strong></p>
<p>##简介</p>
<p>  Mybatis是用于数据库操作，对JDBC技术做了封装。<br>  Mybatis前身是ibatis。</p>
<blockquote>
<p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p>
</blockquote>
<p>  JdbcTemplate和MyBatis对比：</p>
<ul>
<li>都实现了获取连接、生成Statement、执行sql、释放连接等过程</li>
<li>MyBatis封装了返回结果ResultSet数据跟实体类的映射过程（映射实体对象、Map对象、基本数据类型）</li>
<li><p>MyBatis封装了SQL语句参数设置过程（将对象设置到sql参数中，SQL需要采用#{属性名}或${属性名}，建议#{}模式）</p>
<pre><code>参数是：address对象  
insert into address (id,name,zipcode) values (#{id},#{name},#{zipcode})
</code></pre></li>
<li>MyBatis封装了分页查询处理</li>
<li>MyBatis提供了多表关联查询映射</li>
<li>MyBatis提供了映射器，是一套接口，可以顶替DAO</li>
</ul>
<p>##MyBatis结构<br><img src="http://i.imgur.com/7h7blhS.png" alt=""></p>
<p>##Mapper映射器规则</p>
<p> 实现Mapper接口和SQL语句之间的映射，通过Mapper接口方法调用SQL操作。</p>
<ul>
<li><p>SQL定义文件中的<mapper namespace="xx">属性值，必须指定为Mapper接口</mapper></p>
<pre><code>&lt;mapper namespace=&quot;cn.xdl.mapper.DeptMapper&quot;&gt;    
</code></pre></li>
<li><p>Mapper接口方法的方法名与SQL语句的id属性保持一致</p>
</li>
<li>Mapper接口方法的方法参数与SQL语句的parameterType保持一致，没有表示无参</li>
<li>Mapper接口方法的返回类型，增删改操作可以为void 或 int;查询可以是List&lt;resultType映射类型&gt;或 单个对象(resultType映射类型)</li>
</ul>
<p>  参考上述规则写好Mapper接口，使用下面方法应用</p>
<pre><code>SqlSession session = MyBatisUtil.getSession();
DeptMapper deptDao = 
        session.getMapper(DeptMapper.class);
System.out.println(deptDao.getClass().getName());
List&lt;Dept&gt; list = deptDao.findAll();
</code></pre><p>##MyBatis别名（alias）</p>
<p>  在定义SQL语句时，指定parameterType或resultType时，可以使用alias别名。MyBatis内了大量别名，具体如下：</p>
<p>  <img src="http://i.imgur.com/yGeAVGS.png" alt=""></p>
<p>  如果需要自定义类型别名，可以在MyBatis配置文件中指定(sqlmapconfig.xml)</p>
<pre><code>&lt;!-- 定义类型别名 --&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;cn.xdl.entity.Dept&quot; alias=&quot;dept&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre><p>  SQL定义</p>
<pre><code>&lt;select id=&quot;findAll&quot; resultType=&quot;dept&quot;&gt;
    select * from dept
&lt;/select&gt;
</code></pre><p>##MyBatis中JdbcType</p>
<blockquote>
<p>Error updating database.  Cause: org.apache.ibatis.type.TypeException: Error setting null for parameter #1 with JdbcType OTHER . Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. Cause: java.sql.SQLException: 无效的列类型: 1111</p>
</blockquote>
<p>上面异常产生原因，SQL定义中#{属性名}表达式取出null值，需要明确指定字段类型。应该采用#{dname,jdbcType=VARCHAR}。</p>
<p>  可以使用的jdbcType类型如下：<br><img src="http://i.imgur.com/sTe59xo.png" alt=""></p>
<p>##MyBatis打印底层日志</p>
<pre><code>&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre><p>##<em>MyBatis分页查询</em></p>
<ol>
<li>添加pageHelper工具包</li>
<li><p>在sqlmapconfig.xml中，配置pageHelper工具</p>
<pre><code>&lt;plugins&gt;
    &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;
        &lt;property name=&quot;dialect&quot; value=&quot;oracle&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre></li>
<li><p>使用pageHelper工具。</p>
<ul>
<li><p>sqlSession.selectList(“id”,参数,RowBounds对象)</p>
<pre><code>RowBounds bound = new RowBounds(5, 5);//表示从第6条取，取5条
SqlSession session = MyBatisUtil.getSession();
List&lt;Dept&gt; list = session.selectList(&quot;findAll&quot;,null,bound);
</code></pre></li>
<li><p>使用mapper.findAll()之前调用PageHeler.startPage(第几页,一页几条);</p>
<pre><code>SqlSession session = MyBatisUtil.getSession();
DeptMapper deptDao = session.getMapper(DeptMapper.class);
Page page = PageHelper.startPage(2, 5);//表示取第2页，一页5条
List&lt;Dept&gt; list = deptDao.findAll();
</code></pre></li>
</ul>
</li>
</ol>
<ul>
<li></li>
</ul>
<p>##前面技术汇总</p>
<p><img src="http://i.imgur.com/wTSzNUL.png" alt=""></p>
<p>##NoSQL技术</p>
<ol>
<li><p>内存数据库 Redis(NoSQL、非关系型数据库)</p>
<p> 读写快、适合做缓存</p>
</li>
<li><p>文档数据库 MongoDB(NoSQL、非关系型数据库)</p>
<p> 扩展性好、适合集群扩展、存储大量非核心数据</p>
</li>
<li><p>Oracle、MySQL、DB2(SQL、关系型数据库)</p>
<p> 安全性、完整性好、存储核心业务数据</p>
</li>
<li><p>关系型和非关系型区别？</p>
<p>关系型是以表结构作为存储，表之间采用主外键约束表示。<br>非关系型是以Key-Value键值对结构存储  </p>
</li>
</ol>
<p>##Redis命令</p>
<pre><code>Redis中Value值类型有：字符串、哈希、列表、集合、有序集合
</code></pre><ol>
<li><p>字符串操作(重点)</p>
<ul>
<li><p>存入</p>
<p>  set key value</p>
</li>
<li><p>取值</p>
<p>  get key</p>
</li>
<li><p>获取值长度</p>
<p>  strlen key</p>
</li>
<li><p>递增或递减</p>
<p>  incr key<br>  incrby key n<br>  decr key<br>  decrby key n</p>
</li>
<li><p>追加，字符串拼接</p>
<p>  append key value</p>
</li>
</ul>
</li>
<li><p>key操作(重点)</p>
<ul>
<li><p>查看所有key</p>
<p>  keys *</p>
</li>
<li><p>删除key</p>
<p>  del key</p>
</li>
<li><p>修改key名</p>
<p>  rename key newkey</p>
</li>
<li><p>指定过期时间</p>
<p>  expire key 秒</p>
</li>
</ul>
</li>
<li><p>哈希操作(HashMap)</p>
<p> value结构： 字段名1 值1、字段名2 值2</p>
<ul>
<li><p>存入值</p>
<p>  hset key 字段名1 值1<br>  hmset key字段名1 值1、字段名2 值2  </p>
</li>
<li><p>取值</p>
<p>  hget key 字段名<br>  hmget key 字段名1 字段名2  </p>
</li>
<li><p>字段个数</p>
<p>  hlen key</p>
</li>
<li><p>查看所有字段名</p>
<p>  hkeys key</p>
</li>
<li><p>删除某个字段</p>
<p>  hdel key 字段名</p>
</li>
</ul>
</li>
<li><p>列表操作（List）(重点)</p>
<ul>
<li><p>存入值</p>
<p>  lpush key value  //放头部<br>  rpush key value  //放尾部  </p>
</li>
<li><p>取值</p>
<p>  lrange key 0 -1  //取所有<br>  lindex key index //按索引取某一个</p>
</li>
<li><p>更新</p>
<p>  lset key index newvalue</p>
</li>
<li><p>删除</p>
<p>  lrem key count value //删除count个等于value的元素<br>  lpop key //删除第一个元素<br>  rpop key //删除最后一个元素  </p>
</li>
<li><p>获取长度</p>
<p>  llen key </p>
</li>
</ul>
</li>
<li><p>集合操作(Set)</p>
<ul>
<li><p>存入值</p>
<p>  sadd key value value</p>
</li>
<li><p>取值</p>
<p>  smembers key</p>
</li>
<li><p>删除元素</p>
<p>  srem key value</p>
</li>
<li><p>获取长度</p>
<p>  scard key</p>
</li>
<li><p>获取随机元素</p>
<p>  srandmember key count</p>
</li>
<li><p>运算</p>
<p>  交：sinter key1 key2<br>  并：sunion key1 key2<br>  差：sdiff key1 key2  </p>
<pre><code>A = {1 3 5 7}  

B = {3 5 8 2}  

交集：A和B都有的元素 ｛3 5｝  
并集：A加B元素 {1 2 3 5 7 8}  
差集：A差B ｛1 7｝  B差A {2 8}  
</code></pre></li>
</ul>
</li>
<li><p>有序集合</p>
<ul>
<li><p>存入值</p>
<p>  zadd key score value score value</p>
</li>
<li><p>取值</p>
<p>  zrange key 0 -1 //取所有值,由小到大<br>  zrevrange key 0 -1 //取所有值,由大到小</p>
</li>
<li><p>统计</p>
<p>  zcount key  min max//统计分数在min和max之间的元素数量<br>  zcard key //获取元素总数</p>
</li>
<li><p>删除</p>
<p>  zrem key value </p>
</li>
<li><p>获取排名</p>
<p>  zrank key value  //由小到大，获取元素排名索引值<br>  zrevrank key value //由大到小，获取元素排名索引值</p>
</li>
</ul>
</li>
</ol>
<p>##Java对Redis操作</p>
<ol>
<li><p>引入jedis.jar工具包</p>
</li>
<li><p>建立连接</p>
<p> Jedis jedis = new Jedis();//默认连接本机<br> Jedis jedis = new Jedis(host,port);//连接其他机器</p>
</li>
<li><p>数据操作</p>
<p> jedis.get/jedis.set等方法做字符串、哈希、列表、集合、有序集合操作</p>
<pre><code>Jedis jedis = new Jedis();//连接本机Redis
//获取字符串信息
String v1 = jedis.get(&quot;java10&quot;);// get java10
System.out.println(&quot;java10存储的值为&quot;+v1);
//获取List列表信息lrange list1 0 -1
List&lt;String&gt; list = jedis.lrange(&quot;list1&quot;, 0, -1);
for(String s:list){
    System.out.println(s);
}
jedis.close();
</code></pre></li>
</ol>
<p>##Redis缓存应用</p>
<p><img src="http://i.imgur.com/kFLaFEX.png" alt=""></p>
<p>##Spring+Redis集合</p>
<pre><code>Spring框架和Redis结合，需要使用Spring-DATA框架功能。
</code></pre><ol>
<li><p>准备工作</p>
<p> 引入spring-data-redis.jar</p>
</li>
<li><p>在Spring中配置下面组件</p>
<ul>
<li><p>JedisPoolConfig</p>
<pre><code>&lt;bean id=&quot;redisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
    &lt;property name=&quot;maxTotal&quot; value=&quot;100&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>JedisConnectionFactory</p>
<pre><code>&lt;bean id=&quot;redisConnectionFactory&quot; 
class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;
    &lt;property name=&quot;hostName&quot; value=&quot;localhost&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;port&quot; value=&quot;6379&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;poolConfig&quot; ref=&quot;redisPoolConfig&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>RedisTemplate</p>
<pre><code>&lt;bean id=&quot;template&quot; 
    class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;
    &lt;property name=&quot;connectionFactory&quot; ref=&quot;redisConnectionFactory&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>编写RedisDao</p>
<p> 可以将RedisTemplate注入进来，使用Template做写入和取值操作。</p>
<pre><code>@Repository(&quot;redisDao&quot;)//扫描Dao
public class RedisDaoImpl implements RedisDao{

    @Resource//注入Template
    private RedisTemplate template;

    @Override
    public Object getObject(String key) {
        //利用template对象操作
    }

}
</code></pre></li>
</ol>
<p>##MongoDB简介</p>
<p>  分布式文件数据库库，存储格式bson，介于关系型和非关系型数据库之间的一个产品。优点是扩展性好，而且也支持查询、索引等。</p>
<p>  <img src="http://i.imgur.com/0R8461t.png" alt=""></p>
<p>  Mongo一个库可以包含很多集合，每个集合可以存储很多json记录。集合结构如下</p>
<p>  <img src="http://i.imgur.com/t61tfoZ.png" alt=""></p>
<p>##MongoDB命令</p>
<ol>
<li><p>库</p>
<ul>
<li><p>查看所有库</p>
<pre><code>show databases
</code></pre></li>
<li><p>使用一个库</p>
<pre><code>use 库名
</code></pre></li>
<li><p>创建一个库</p>
<pre><code>use 库名
</code></pre></li>
<li><p>删除一个库</p>
<pre><code>db.dropDatabase() //删除当前进入的库
</code></pre></li>
</ul>
</li>
<li><p>集合</p>
<p> 提示：一定要先use库，进入库之后才能做集合操作</p>
<ul>
<li><p>查看当前库中所有集合</p>
<p>  show collections</p>
</li>
<li><p>插入记录</p>
<p>  db.集合名.insert(xxx);//xxx为json数据</p>
</li>
<li><p>查询记录</p>
<p>  db.集合名.find(); </p>
</li>
<li><p>删除记录</p>
<p>  db.集合名.remove();</p>
</li>
<li><p>更新记录</p>
<p>  db.集合名.update();</p>
</li>
<li><p>count统计</p>
<p>  db.集合名.count();</p>
</li>
<li><p>删除集合</p>
<p>  db.集合名.drop();</p>
</li>
</ul>
</li>
<li><p>索引</p>
<ul>
<li><p>创建索引</p>
<p>  db.集合名.ensureIndex({“属性名”:1或-1}) //1升序;-1降序</p>
</li>
<li><p>删除索引</p>
<p>  db.集合名.dropIndexes(“属性名字_1”)</p>
</li>
</ul>
</li>
</ol>
<p>##Java访问MongoDB</p>
<ol>
<li><p>导入mongo驱动包</p>
<pre><code>mongo-java-driver-2.13.2.jar
</code></pre></li>
<li><p>建立连接</p>
<pre><code>MongoClient mongo = new MongoClient();
</code></pre></li>
<li><p>访问库信息</p>
<pre><code>DB db = mongo.getDB(&quot;java10&quot;);
</code></pre></li>
</ol>
<ol start="4">
<li><p>访问集合信息</p>
<pre><code>DB db = mongo.getDB(&quot;java10&quot;);
DBCollection coll = db.getCollection(&quot;dept&quot;);
DBCursor cursor = coll.find();
</code></pre></li>
<li><p>分页查询</p>
<pre><code>DB db = mongo.getDB(&quot;java10&quot;);
DBCollection coll = db.getCollection(&quot;dept&quot;);
DBCursor cursor = coll.find().skip(2).limit(2);
</code></pre></li>
</ol>
<p>#MAVEN</p>
<p>  用于项目构建和管理。包含创建Project、编译、测试、打包、发布。</p>
<h4 id="1-命令行"><a href="#1-命令行" class="headerlink" title="1. 命令行"></a>1. 命令行</h4><pre><code>- 下载maven工具包，解压到某个目录，配置系统环境变量PATH
- 打开cmd命令行，进入project执行mvn命令

mvn clean  //清除编译结果
mvn build  //编译、打包
mvn test   //运行测试类
mvn install  //编译、打包、发布本地仓库
</code></pre><h4 id="2-Eclipse集成MAVEN"><a href="#2-Eclipse集成MAVEN" class="headerlink" title="2. Eclipse集成MAVEN"></a>2. Eclipse集成MAVEN</h4><pre><code>- 下载maven工具包，解压到某个目录
- 在eclipse配置maven路径和settings.xml
- 利用eclipse右键创建maven project，点击project右键执行编译、测试、打包菜单
</code></pre><p>###3.Project结构改变</p>
<p><strong>web project</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.imgur.com/jUWuwwq.png" alt=""></h2><p><strong>maven project</strong></p>
<p><img src="https://i.imgur.com/huUt1Po.png" alt=""></p>
<p>####4.Eclipse创建MAVEN project</p>
<p> <img src="https://i.imgur.com/fUCrT83.png" alt=""></p>
<p>#StrutsPrepareAndExecuteFilter</p>
<p>作用：前端（主）控制器、用于接收请求、按struts.xml配置转发处理<br>配置：web.xml、&lt; filter&gt;、&lt; filter-mapping&gt;  </p>
<ul>
<li>浏览器发送请求、请求最先进入Filter控制器</li>
<li>Filter会先进行请求过滤、Action请求才会进入struts.xml<br>  (默认：*.action或没有扩展名请求才会进入Action)</li>
<li>Filter会创建并初始化一个ValueStack对象</li>
<li>Filter调用Interceptor拦截器处理</li>
<li>Filter根据struts.xml配置找Action处理（按namespace+actionName），调用Action对象的execute方法处理（method=”xxx”）</li>
<li>Filter根据Action对象execute方法返回结果调用Result组件</li>
<li>使用Result生成响应结果，给浏览器输出</li>
</ul>
<p>#Action</p>
<ol>
<li><p>属性</p>
<p> 作用：可以接收请求参数、可以向响应JSP传值</p>
<p> private String xxx;  </p>
<p> public void setXxx(){…}<br> public String getXxx(){…}//${xxx}</p>
</li>
</ol>
<pre><code>private String _name;  
public String getName(){...}//${name}  
</code></pre><ol start="2">
<li><p>方法</p>
<p> public String xxx|execute(){…}</p>
</li>
<li><p>API</p>
<p> ActionContext、ServletActionContext<br> SessionAware、RequestAware、ServletRequestAware等  </p>
</li>
</ol>
<p>#Result</p>
<ol>
<li><p>原理</p>
<p> public class ServletDispatcherResult implements Result{</p>
<pre><code>private String location;

//setLocation、getLocation

public void execute(){
    HttpServletRequest request =  ServletActionContext.getRequest();
    HttpServletResponse respones = ServletActionContext.getResponse();
    request.getRequestDispatcher(location).forward(request,response)
}
</code></pre><p> }</p>
</li>
<li><p>分类和使用</p>
<p> Result组件不需要开发者编写，框架提供了大量内置的Result组件，可以满足使用需求。</p>
<ul>
<li><p>JSP</p>
<p>  dispatcher : 转发调用jsp<br>  redirect : 重定向调用jsp  </p>
</li>
<li><p>Action</p>
<p>  chain : 转发调用action<br>  redirectAction : 重定向调用action </p>
<p>  请求–&gt;Action1–&gt;Action2  </p>
</li>
</ul>
</li>
</ol>
<pre><code>- 字节流响应

    stream ： 将Action中InputStream属性的信息以字节流方式输出

- json响应

    json : 将Action中属性以json字符串方式输出
</code></pre><ol start="3">
<li><p>验证码示例</p>
<p> /user/image.do–&gt;Filter控制器–&gt;ImageAction–&gt;Result(stream)–&gt;字节流输出</p>
</li>
<li><p>验证码校验</p>
<p> ajax请求\返回json结果\ajax回调函数显示结果信息</p>
<p> /user/checkcode.do–&gt;Filter–&gt;CheckCodeAction–&gt;Result(json)–&gt;返回json结果</p>
<ul>
<li><p>增加json类型result</p>
<p>  添加struts2-json-plugin.jar工具包<br>  将&lt; package&gt;的extends属性继承json-default  </p>
</li>
<li><p>使用方法(配置)</p>
<pre><code>&lt;action class=&quot;xxxAction&quot;&gt;
    &lt;result name=&quot;success&quot; type=&quot;json&quot;&gt;
        &lt;param name=&quot;root&quot;&gt;一个属性名&lt;/param&gt;
        &lt;param name=&quot;includeProperties&quot;&gt;
        属性名1,属性名2
        &lt;/param&gt;
    &lt;/result&gt;
&lt;/action&gt;
</code></pre></li>
</ul>
</li>
</ol>
<p>#Interceptor</p>
<ol>
<li><p>原理</p>
<p> 拦截器是拦截Action，在Action调用之前执行。可以使用拦截器封装一些通用处理。例如登录检查、性能检测等。</p>
<p> Struts2框架内部有大量拦截器，每次发送请求，请求调用Action前都会默认指定一个defaultStack的拦截器栈。</p>
<p> params: 可以将request请求参数提取出来，然后给Action对象同名属性赋值。</p>
</li>
</ol>
<pre><code>请求--&gt;Filter--&gt;拦截器(defaultStack/params)--&gt;Action.execute

public class ParametersInterceptor implements Interceptor{
    public void intercept(){
        //拦截器处理逻辑
        //获取request请求参数,然后给Action对象属性赋值
    }
}
</code></pre><ol start="2">
<li><p>登录检查</p>
<p> 作用：进行登录检查，如果没登录不允许调用Action处理，跳转到login.jsp</p>
</li>
<li><p>拦截器注意事项</p>
<p> 为某个<action>指定了拦截器之后，默认的defaultStack拦截器不会再调用，原有功能会收影响，因此必须显式调用下。</action></p>
<pre><code>&lt;interceptor-stack name=&quot;loginStack&quot;&gt;
    &lt;interceptor-ref name=&quot;checklogin&quot;/&gt;
    &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;
&lt;/interceptor-stack&gt;
</code></pre></li>
</ol>
<p>#ValueStack</p>
<p>#Struts2注解配置</p>
<pre><code>引入struts2-convention-plugin.jar

&lt;dependency&gt;
  &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;
  &lt;artifactId&gt;struts2-convention-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.3.31&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>@Action ： &lt; action&gt;<br>@Result ： &lt; result&gt;<br>@Namespace ： <package namespace="xx"><br>@ParentPackage : <package extends="xx"><br>@InterceptorRef : <interceptor-ref></interceptor-ref></package></package></p>
<p>##Spring MVC RESTFUL中PUT参数接收</p>
<ol>
<li><p>ajax</p>
<p> $.ajax({  </p>
<pre><code>url:&quot;update.do&quot;,  
**type:&quot;put&quot;,  
data:&apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;java&quot;}&apos;,  
contentType:&quot;application/json&quot;,**  
dataType:&quot;json&quot;,  
success:function(){...}  
</code></pre><p> });</p>
</li>
</ol>
<ol start="2">
<li><p>Controller</p>
<p> //利用@RequestBody将请求传递过来的json串转成user对象<br> public ResponseResult update(@RequestBody User user){</p>
<p> }</p>
</li>
</ol>
<p>##SpringMVC ajax跨域</p>
<pre><code>前后端分离后，如果前后端采用不同域名部署，ajax通信会被中断。解决方法一般有两种，第一种jsonp模式，第二种用Filter在Server端设置允许哪些域名请求.
</code></pre><ol>
<li><p>第二种代码如下</p>
<pre><code>package com.mengyao.system.filter;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

/**
 * CORSFilter 解决跨域问题
 *
 */
@Component
public class InitCORSFilter extends OncePerRequestFilter {

private Logger logger = LoggerFactory.getLogger(InitCORSFilter.class);

public InitCORSFilter() {
    logger.info(&quot;==== 初始化系统允许跨域请求 ====&quot;);
}

/**
 * 解决跨域：Access-Control-Allow-Origin，值为*表示服务器端允许任意Domain访问请求
 */
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {
    if (request.getHeader(&quot;Access-Control-Request-Method&quot;) != null &amp;&amp; &quot;OPTIONS&quot;.equals(request.getMethod())) {
        response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
        response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);
        response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;origin, content-type, accept, x-requested-with, sid, mycustom, smuser&quot;);
        response.addHeader(&quot;Access-Control-Max-Age&quot;, &quot;1800&quot;);//30 min
    }
    filterChain.doFilter(request, response);
}

}
</code></pre><p> 然后Server端项目中，在web.xml配置该Filter组件即可</p>
</li>
</ol>
<p>#Hibernate</p>
<p>  JDBC–&gt;JdbcTemplate–&gt;MyBatis–&gt;Hibernate</p>
<p>  Hibernate主要用于对数据库操作，为应用程序构建一个持久层。</p>
<p><img src="https://i.imgur.com/DBqRqcN.png" alt=""></p>
<p>#Hibernate查询操作</p>
<p>##HQL查询<br>Hibernate Query Language，面向对象查询语言。</p>
<p>SQL Strctor Query Language 结构化查询语言。</p>
<p>HQL和SQL语法结构是一致的，支持</p>
<pre><code>select...
from...
where...
group by...
having...
order by...
</code></pre><p>HQL和SQL语法的不同</p>
<ul>
<li>HQL使用类和属性名字、SQL使用表和字段名字</li>
<li>HQL中类和属性名是区分大小写的、SQL表和字段名不区分</li>
<li>HQL支持max、min、avg、count、sum分组函数,但不支持数据库日期、字符串等函数、也不支持sysdate、now()等关键字</li>
<li>HQL不支持select <em> 写法、支持select count(</em>)，如果需要取所有记录可以省略select子句</li>
<li>HQL不支持join…on…写法中的on子句，需要使用关联映射</li>
</ul>
<p>SQL: select * from NOTE<br>HQL: from Note</p>
<p>SQL: select context,publish_time from NOTE where ID=?<br>HQL: select context,publishTime from Note where id=?</p>
<pre><code>Query query = session.createQuery(hql);
</code></pre><p>##Criteria查询<br>条件查询，基于方法指定查询数据源、条件、排序等等。</p>
<pre><code>Criteria ct = session.createCriteria(Note.class);
</code></pre><p>##NativeSQL查询<br>原生SQL查询</p>
<pre><code>SQLQuery sqlQuery = session.createSQLQuery(sql);
</code></pre><p>#Hibernate注解应用</p>
<ol>
<li><p>注解标记</p>
<p> @Entity<br> @Table<br> @Id<br> @GeneratedValue<br> @Column  </p>
</li>
<li><p>加载映射描述信息</p>
<p> hibernate.cfg.xml中</p>
<p> &lt; mapping class=”cn.xdl.entity.Note”/&gt;</p>
</li>
</ol>
<p>#Hibernate特性</p>
<ol>
<li><p>延迟加载</p>
<p> 数据在执行一些查询时，有些API方法具有延迟特性，执行完方法后并没有立刻发送SQL加载数据，而是在使用对象数据时才会发送SQL加载数据。</p>
<p> session.load()//延迟机制=session.get()//立刻加载</p>
<p> query.iterator()//延迟机制=query.list()//立刻加载  </p>
<p> 关联映射查询操作//延迟机制</p>
<p> 延迟加载方法应用，经常会遇到下面问题。</p>
<pre><code>org.hibernate.LazyInitializationException: could not initialize proxy - no Session
</code></pre><p> 产生原因是：session关闭过早，导致发送SQL实例化失败</p>
<p> 请求–&gt;Filter–&gt;Action–&gt;DAO(不关session)–&gt;Result–&gt;JSP(EL)–&gt;关闭session</p>
<p> 方案：可以用Filter过滤器、拦截器、AOP技术实现控制session关闭。(OpenSessionInView方案)<br> Spring框架提供了一个OpenSessionInViewFilter组件，可以回收session资源，支持延迟加载操作。(在web.xml配置即可)</p>
<p> public void doFilter(){</p>
<pre><code>chain.doFilter();//调用servlet/jsp
//sessoin.close();
</code></pre><p> }</p>
</li>
</ol>
<ol start="2">
<li><p>持久化</p>
<p> 在Hibernate框架中，实体对象会有三种存在状态。</p>
</li>
</ol>
<pre><code>![](https://i.imgur.com/M5cKYYT.jpg)

- 临时状态（Transient）
    new Xxx();

- 持久状态 (Persistent)
    跟session发生关联,load/get/save/update

    特点：垃圾回收器不能回收、对象属性信息可以更新数据库

    同步时机：session.flush()，tx.commit()内部会自动调用flush(). 

- 游离状态 (Detached)
    本来是持久状态，但是却调用了clear/evict/close方法
</code></pre><ol start="3">
<li><p>缓存（性能优化）</p>
<ul>
<li><p>一级缓存(自动启用)</p>
<p>  每个Session都有一个缓存区，被称为一级缓存区。生成周期跟着Session一致。缓存区是Session对象独享。</p>
<p>  优点：查询同一个对象多次，第一次查数据库，后续查缓存</p>
<p>  缓存和持久化关系：缓存中的对象具有持久化状态的。将对象从缓存移除，对象就变为游离。</p>
<p>  手动管理缓存的方法：evict()\clear()\close</p>
</li>
<li><p>二级缓存</p>
</li>
</ul>
</li>
</ol>
<pre><code>- 查询缓存
</code></pre><p>#Spring+Hibernate整合</p>
<p><img src="https://i.imgur.com/FGzECIe.png" alt=""></p>
<p>##HibernateTemplate</p>
<ol>
<li><p>引入spring和hibernate开发包和配置文件</p>
<p> 参考示例中的<br> pom.xml//jar包导入<br> applicationContext.xml//spring配置文件<br> hibernate.cfg.xml//hibernate配置文件    </p>
</li>
<li><p>编写实体类和映射描述信息</p>
<p> 参考示例中Note.java</p>
</li>
<li><p>在Spring中配置HibernateTemplate组件</p>
<pre><code>&lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTemplate&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>在Spring中配置SessionFactory组件</p>
<pre><code>&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;
&lt;!-- 指定连接池 --&gt;
&lt;property name=&quot;dataSource&quot; ref=&quot;c3p0&quot;&gt;
&lt;/property&gt;
&lt;!-- 指定hibernate.cfg.xml，删除数据库链接参数 --&gt;
&lt;property name=&quot;configLocations&quot; value=&quot;classpath:hibernate.cfg.xml&quot;&gt;
&lt;/property&gt;
</code></pre><p> </p>
</li>
<li><p>配置DataSource组件</p>
<pre><code>&lt;bean id=&quot;c3p0&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
    &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/studyonline?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>使用HibernateTemplate对象操作</p>
<ul>
<li>find(hql,params)//执行hql</li>
<li>save</li>
<li>delete</li>
<li>update</li>
<li><p>load/get</p>
<p>可以去编写NoteDao接口和实现类，将HibernateTemplate注入完成数据库操作</p>
</li>
</ul>
</li>
</ol>
<p>##AOP事务管理</p>
<pre><code>&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 支持@Transactional --&gt;
&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; 
    proxy-target-class=&quot;true&quot;/&gt;
</code></pre><p>在ListAction或DeleteAction追加@Transactional标记就可以了</p>
<p>#笔记详情</p>
<ol>
<li><p>流程</p>
<p> /demo/view.do?id=xx–&gt;Filter控制器–&gt;ViewAction–&gt;NoteDao.findById–&gt;NOTE–&gt;Result–&gt;/WEB-INF/view.jsp</p>
</li>
<li><p>为了支持Hibernate延迟加载操作load，配置OpenSessionInViewFilter</p>
<pre><code>&lt;!-- opensessioninviewfilter,放在struts2 filter之前 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;opensession&lt;/filter-name&gt;
    &lt;filter-class&gt;
    org.springframework.orm.hibernate4.support.OpenSessionInViewFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;opensession&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></li>
</ol>
<p>#关联映射</p>
<p>##多对一many-to-one</p>
<ol>
<li>建立User和Note的单表映射</li>
<li>在Note类中加user属性，删除原有的userId属性</li>
<li><p>在user属性前追加下面标记</p>
<pre><code>//追加关联属性 Note(n)   User(1)
@ManyToOne(fetch=FetchType.LAZY)
@JoinColumn(name=&quot;USER_ID&quot;)
private User user;

public User getUser() {
    return user;
}
</code></pre></li>
</ol>
<p>##一对多one-to-many</p>
<ol>
<li>建立User和Note的单表映射</li>
<li>在User中加notes集合属性</li>
<li><p>在notes属性前追加下面标记</p>
<pre><code>//追加属性
@OneToMany(fetch=FetchType.EAGER)
@JoinColumn(name=&quot;USER_ID&quot;)
private List&lt;Note&gt; notes;

public List&lt;Note&gt; getNotes() {
    return notes;
}

public void setNotes(List&lt;Note&gt; notes) {
    this.notes = notes;
}
</code></pre></li>
</ol>
<pre><code>from User u join fetch u.notes where u.id=?//返回User

from User u join u.notes n where u.id=?//返回Object[][user,note]
</code></pre><p>##缓存</p>
<ul>
<li>一级缓存（Session）<br>session独享.</li>
<li>二级缓存（SessionFactory）<br>session共享.</li>
</ul>
<p>###二级缓存开启方法</p>
<p>二级缓存默认关闭,开启方法如下：</p>
<ul>
<li><p>先引入二级缓存组件包和配置文件<br>  (hibernate-ehcache.jar/ehcache.xml)</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
  &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt;
  &lt;version&gt;4.2.21.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li>
<li><p>修改hibernate.cfg.xml配置文件，开启二级缓存配置</p>
<pre><code>&lt;property name=&quot;hibernate.cache.use_sencond_level_cache&quot;&gt;true&lt;/property&gt;
&lt;property name=&quot;hibernate.cache.region.factory_class&quot;&gt;
    org.hibernate.cache.ehcache.EhCacheRegionFactory
&lt;/property&gt;
</code></pre></li>
<li><p>在映射描述中指定采用二级缓存</p>
<p>  @Cache加载类定义前/<cache>加到hbm.xml中</cache></p>
<pre><code>@Entity
@Table(name=&quot;NOTE&quot;)
@Cache(usage=CacheConcurrencyStrategy.READ_ONLY)
public class Note {
    ... ...

    @ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name=&quot;USER_ID&quot;)
    @Cache(usage=CacheConcurrencyStrategy.READ_ONLY)
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

}
</code></pre></li>
</ul>
<p>###查询缓存开启方法</p>
<pre><code>一级和二级只能缓存单个对象，查询缓存可以缓存集合。

开启方法如下：
</code></pre><ul>
<li>开启二级缓存</li>
<li><p>在hibernate.cfg.xml中开启查询缓存</p>
  <property name="hibernate.cache.use_query_cache">true</property></li>
<li><p>在执行查询语句之前，调用query.setCacheable(true);</p>
<p>  Query query = session.createQuery(“from Note”);<br>  query.setCacheable(true);<br>  List<note> list = query.list();//执行查询</note></p>
</li>
</ul>
<p>##Ngnix+Tomcat集群</p>
<pre><code> //添加upstream
upstream server_list{
 server localhost:8080;
 server localhost:8081;
 }

 server {
     listen       80;
     server_name  localhost;

     #charset koi8-r;

     #access_log  logs/host.access.log  main;

     location / {
         root   html;
         index  index.html index.htm;

         //添加proxy_pass
            proxy_pass http://server_list/;
     }
</code></pre><p>##多个Tomcat同步Session</p>
<p>分别修改tomcat的server.xml配置文件</p>
<ol>
<li><p>为<engine>元素指定jvmRoute属性名,名称保持一致</engine></p>
<pre><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat1&quot;&gt;
</code></pre></li>
<li><p>释放开<cluster>元素注释</cluster></p>
<pre><code>&lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;
</code></pre></li>
<li><p>在项目project的web.xml中配置&lt; distributable/&gt;元素</p>
<pre><code>&lt;distributable/&gt;
</code></pre></li>
</ol>
<p>##nginx+tomcat+redis完成session共享</p>
<ol>
<li>安装redis、tomcat、nginx</li>
<li><p>session同步配置</p>
<ul>
<li><p>下载jar包,放入到tomcat/lib目录下</p>
<p>  tomcat-redis-session-manager-1.2-tomcat-7-java-7.jar</p>
<p>  jedis-2.5.2.jar</p>
<p>  commons-pool2-2.0.jar</p>
</li>
<li><p>修改tomcat中context.xml文件</p>
<pre><code>  &lt;Context&gt;  

  &lt;!-- Default set of monitored resources --&gt;  
  &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;  

  &lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt;  
  &lt;!-- 
  &lt;Manager pathname=&quot;&quot; /&gt; 
  --&gt;  

  &lt;!-- Uncomment this to enable Comet connection tacking (provides events  
       on session expiration as well as webapp lifecycle) --&gt;  
  &lt;!-- 
  &lt;Valve className=&quot;org.apache.catalina.valves.CometConnectionManagerValve&quot; /&gt; 
  --&gt;  

&lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt;  
&lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;  
 host=&quot;10.10.49.20&quot;  
 port=&quot;6379&quot;  
 database=&quot;0&quot;  
 maxInactiveInterval=&quot;60&quot; /&gt;  
</code></pre><p>    </p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/07/springNote/" data-id="cjgwc5drk00033k6twam32ot7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/05/06/JSON对象解析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JSON对象解析小工具</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/07/springNote/">spring知识点</a>
          </li>
        
          <li>
            <a href="/2018/05/06/JSON对象解析/">JSON对象解析小工具</a>
          </li>
        
          <li>
            <a href="/2018/05/06/FirstNight/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/05/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 laofuzi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>